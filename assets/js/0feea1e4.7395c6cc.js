"use strict";(self.webpackChunkdocu=self.webpackChunkdocu||[]).push([[7783],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>d});var o=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function c(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?c(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):c(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function a(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},c=Object.keys(e);for(o=0;o<c.length;o++)n=c[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var c=Object.getOwnPropertySymbols(e);for(o=0;o<c.length;o++)n=c[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=o.createContext({}),l=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=l(e.components);return o.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},h=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,c=e.originalType,s=e.parentName,p=a(e,["components","mdxType","originalType","parentName"]),h=l(n),d=r,m=h["".concat(s,".").concat(d)]||h[d]||u[d]||c;return n?o.createElement(m,i(i({ref:t},p),{},{components:n})):o.createElement(m,i({ref:t},p))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var c=n.length,i=new Array(c);i[0]=h;var a={};for(var s in t)hasOwnProperty.call(t,s)&&(a[s]=t[s]);a.originalType=e,a.mdxType="string"==typeof e?e:r,i[1]=a;for(var l=2;l<c;l++)i[l]=n[l];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}h.displayName="MDXCreateElement"},2118:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>c,metadata:()=>a,toc:()=>l});var o=n(87462),r=(n(67294),n(3905));const c={},i="Step 4: Connection Checking",a={unversionedId:"connector-development/cdk-tutorial-python-http/connection-checking",id:"connector-development/cdk-tutorial-python-http/connection-checking",title:"Step 4: Connection Checking",description:"The second operation in the Airbyte Protocol that we'll implement is the check operation.",source:"@site/../docs/08-connector-development/02-cdk-tutorial-python-http/4-connection-checking.md",sourceDirName:"08-connector-development/02-cdk-tutorial-python-http",slug:"/connector-development/cdk-tutorial-python-http/connection-checking",permalink:"/connector-development/cdk-tutorial-python-http/connection-checking",draft:!1,editUrl:"https://github.com/airbytehq/airbyte/blob/master/docs/../docs/08-connector-development/02-cdk-tutorial-python-http/4-connection-checking.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Step 3: Define Inputs",permalink:"/connector-development/cdk-tutorial-python-http/define-inputs"},next:{title:"Step 5: Declare the Schema",permalink:"/connector-development/cdk-tutorial-python-http/declare-schema"}},s={},l=[],p={toc:l};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"step-4-connection-checking"},"Step 4: Connection Checking"),(0,r.kt)("p",null,"The second operation in the Airbyte Protocol that we'll implement is the ",(0,r.kt)("inlineCode",{parentName:"p"},"check")," operation."),(0,r.kt)("p",null,"This operation verifies that the input configuration supplied by the user can be used to connect to the underlying data source. Note that this user-supplied configuration has the values described in the ",(0,r.kt)("inlineCode",{parentName:"p"},"spec.yaml")," filled in. In other words if the ",(0,r.kt)("inlineCode",{parentName:"p"},"spec.yaml")," said that the source requires a ",(0,r.kt)("inlineCode",{parentName:"p"},"username")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"password")," the config object might be ",(0,r.kt)("inlineCode",{parentName:"p"},'{ "username": "airbyte", "password": "password123" }'),". You should then implement something that returns a json object reporting, given the credentials in the config, whether we were able to connect to the source."),(0,r.kt)("p",null,"In order to make requests the API, we need to specify the access\nIn our case, this is a fairly trivial check since the API requires no credentials. Instead, let's verify that the user-input ",(0,r.kt)("inlineCode",{parentName:"p"},"base")," currency is a legitimate currency. In ",(0,r.kt)("inlineCode",{parentName:"p"},"source.py")," we'll find the following autogenerated source:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'class SourcePythonHttpTutorial(AbstractSource):\n\n    def check_connection(self, logger, config) -> Tuple[bool, any]:\n        """\n        TODO: Implement a connection check to validate that the user-provided config can be used to connect to the underlying API\n\n        See https://github.com/airbytehq/airbyte/blob/master/airbyte-integrations/connectors/source-stripe/source_stripe/source.py#L232\n        for an example.\n\n        :param config:  the user-input config object conforming the connector\'s spec.yaml\n        :param logger:  logger object\n        :return Tuple[bool, any]: (True, None) if the input config can be used to connect to the API successfully, (False, error) otherwise.\n        """\n        return True, None\n\n...\n')),(0,r.kt)("p",null,"Following the docstring instructions, we'll change the implementation to verify that the input currency is a real currency:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'    def check_connection(self, logger, config) -> Tuple[bool, any]:\n        accepted_currencies = {"USD", "JPY", "BGN", "CZK", "DKK"}  # assume these are the only allowed currencies\n        input_currency = config[\'base\']\n        if input_currency not in accepted_currencies:\n            return False, f"Input currency {input_currency} is invalid. Please input one of the following currencies: {accepted_currencies}"\n        else:\n            return True, None\n')),(0,r.kt)("p",null,"Note: in a real implementation you should write code to connect to the API to validate connectivity and not just validate inputs - for an example see ",(0,r.kt)("inlineCode",{parentName:"p"},"check_connection")," in the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/airbytehq/airbyte/blob/master/airbyte-integrations/connectors/source-onesignal/source_onesignal/source.py"},"OneSignal source connector implementation")),(0,r.kt)("p",null,"Let's test out this implementation by creating two objects: a valid and an invalid config and attempt to give them as input to the connector. For this section, you will need to take the API access key generated earlier and add it to both configs. Because these configs contain secrets, we recommend storing configs which contain secrets in ",(0,r.kt)("inlineCode",{parentName:"p"},"secrets/config.json")," because the ",(0,r.kt)("inlineCode",{parentName:"p"},"secrets")," directory is gitignored by default."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},'mkdir sample_files\necho \'{"start_date": "2022-04-01", "base": "USD", "access_key": <your_access_key>}\'  > secrets/config.json\necho \'{"start_date": "2022-04-01", "base": "BTC", "access_key": <your_access_key>}\'  > secrets/invalid_config.json\npython main.py check --config secrets/config.json\npython main.py check --config secrets/invalid_config.json\n')),(0,r.kt)("p",null,"You should see output like the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},'> python main.py check --config secrets/config.json\n{"type": "CONNECTION_STATUS", "connectionStatus": {"status": "SUCCEEDED"}}\n\n> python main.py check --config secrets/invalid_config.json\n{"type": "CONNECTION_STATUS", "connectionStatus": {"status": "FAILED", "message": "Input currency BTC is invalid. Please input one of the following currencies: {\'DKK\', \'USD\', \'CZK\', \'BGN\', \'JPY\'}"}}\n')))}u.isMDXComponent=!0}}]);